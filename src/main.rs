// use std::collections::HashMap;
// use std::env;
// use std::fs;
use std::io;

use palette::{
    rgb::{Rgb, Srgb},
    FromColor, Hsv, IntoColor,
};

use tes3::esp::*;

fn main() -> io::Result<()> {
    let config = openmw_cfg::get_config().expect("Failed to get config");
    let plugins = openmw_cfg::get_plugins(&config).expect("Failed to get plugins");

    // Values to come from toml config
    let disable_flickering = true;

    let standard_hue = 0.62;
    let standard_saturation = 0.8;
    let standard_radius = 1.2;
    let standard_value = 0.57;

    let colored_hue = 1.0;
    let colored_saturation = 0.9;
    let colored_value = 0.7;
    let colored_radius = 1.11;

    let mut generated_plugin = Plugin::new();
    let mut used_ids: Vec<String> = Vec::new();

    let mut header = Header {
        version: 1.3,
        author: FixedString("S3".to_string()),
        description: FixedString("Plugin generated by s3-lightfixes".to_string()),
        ..Default::default()
    };

    for plugin_path in plugins.iter().rev() {
        let extension = match plugin_path.extension() {
            Some(extension) => extension,
            None => continue,
        };

        // You really should only have elder scrolls plugins as content entries
        // but I simply do not trust these people
        if extension != "esp"
            && extension != "esm"
            && extension != "omwaddon"
            && extension != "omwgame"
        {
            continue;
        }

        let mut plugin = match Plugin::from_path(plugin_path) {
            Ok(plugin) => plugin,
            Err(e) => {
                eprintln!(
                    "Failed to load plugin from {}: {}",
                    plugin_path.display(),
                    e
                );
                continue;
            }
        };
        let mut used_objects = 0;

        // Disable sunlight color for true interiors
        for cell in plugin.objects_of_type::<Cell>() {
            let cell_id = cell.editor_id_ascii_lowercase().to_string();

            if !cell.data.flags.contains(CellFlags::IS_INTERIOR) || used_ids.contains(&cell_id) {
                continue;
            };

            let mut cell_copy = cell.clone();
            cell_copy.references.clear();
            if let Some(atmosphere) = &cell_copy.atmosphere_data {
                cell_copy.atmosphere_data = Some(AtmosphereData {
                    sunlight_color: [0, 0, 0, 0],
                    fog_density: atmosphere.fog_density,
                    fog_color: atmosphere.fog_color,
                    ambient_color: atmosphere.fog_color,
                })
            }

            generated_plugin.objects.push(TES3Object::Cell(cell_copy));
            used_ids.push(cell_id);
            used_objects += 1;
        }

        for light in plugin.objects_of_type_mut::<Light>() {
            let light_id = light.editor_id_ascii_lowercase().to_string();
            if used_ids.contains(&light_id) {
                continue;
            }

            if disable_flickering {
                light
                    .data
                    .flags
                    .remove(LightFlags::FLICKER | LightFlags::FLICKER_SLOW);
            }

            if light.data.flags.contains(LightFlags::NEGATIVE) {
                light.data.flags.remove(LightFlags::NEGATIVE);
                light.data.radius = 0;
                continue;
            }

            let rgb = Srgb::new(
                light.data.color[0],
                light.data.color[1],
                light.data.color[2],
            )
            .into_format();

            let mut hsv: Hsv = Hsv::from_color(rgb);
            let hue = hsv.hue.into_degrees();

            if hue > 64.0 || hue < 14.0 {
                light.data.radius = (colored_radius * light.data.radius as f32) as u32;
                hsv = Hsv::new(
                    hue * colored_hue,
                    hsv.saturation * colored_saturation,
                    hsv.value * colored_value,
                );
            } else {
                light.data.radius = (standard_radius * light.data.radius as f32) as u32;
                hsv = Hsv::new(
                    hue * standard_hue,
                    hsv.saturation * standard_saturation,
                    hsv.value * standard_value,
                );
            }

            let rgbf_color: Srgb = hsv.into_color();
            let rgb8_color: Srgb<u8> = rgbf_color.into_format();

            light.data.color = [rgb8_color.red, rgb8_color.green, rgb8_color.blue, 0];

            generated_plugin
                .objects
                .push(TES3Object::Light(light.clone()));
            used_ids.push(light_id);
            used_objects += 1;
        }

        if used_objects > 0 {
            let plugin_size = std::fs::metadata(plugin_path)?.len();
            let plugin_string = plugin_path
                .file_name()
                .expect("Plugins must exist to be loaded by openmw-cfg crate!")
                .to_string_lossy()
                .to_owned()
                .to_string();
            header.masters.insert(0, (plugin_string, plugin_size))
        }
    }

    generated_plugin.objects.push(TES3Object::Header(header));
    generated_plugin.sort_objects();

    let _ = generated_plugin.save_path("S3LightFixes.omwaddon");

    dbg!(&generated_plugin);

    Ok(())
}

const NO_HOME: &str = "BAAAAHHH";
pub fn default_config_path() -> String {
    if cfg!(target_os = "linux") {
        format!(
            "{}/.config/openmw/openmw.cfg",
            std::env::var("HOME").expect(NO_HOME)
        )
    } else if cfg!(target_os = "macos") {
        format!(
            "{}/Library/Preferences/openmw/openmw.cfg",
            std::env::var("HOME").expect(NO_HOME)
        )
    } else if cfg!(target_os = "windows") {
        format!(
            "C:\\Users\\{}\\Documents\\My Games\\OpenMW\\openmw.cfg",
            std::env::var("USERNAME").expect(NO_HOME)
        )
    } else {
        panic!("Unsupported operating system");
    }
}

pub fn default_userdata_path() -> String {
    if cfg!(target_os = "linux") {
        format!(
            "{}/.local/share/openmw/data/",
            std::env::var("HOME").expect(NO_HOME)
        )
    } else if cfg!(target_os = "macos") {
        format!(
            "{}/Library/Application Support/openmw/data/",
            std::env::var("HOME").expect(NO_HOME)
        )
    } else if cfg!(target_os = "windows") {
        format!(
            "C:\\Users\\{}\\Documents\\My Games\\OpenMW\\data\\",
            std::env::var("USERNAME").expect(NO_HOME)
        )
    } else {
        panic!("Unsupported operating system");
    }
}
